# SpringCloud Stream消息驱动

什么是SpringCloudStream

官方定义Spring Cloud Stream是一个 构建消息驱动微服务的框架。

应用程序通过inputs或者outputs与Spring Cloud Stream中binder对象交互。
通过我们配置来binding(绑定) ,而Spring Cloud Stream的binder对象负责与消息中间件交互。
所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。

通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。

Spring Cloud Stream为- -些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。

==目前仅支持RabbitMQ、Kafka.==

**屏蔽底层消息中间件的差异，降低切换版本，统一消息的编程模型**



## 设计思想

在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候,
由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性
**通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。**
通过向应用程序暴露统-的Channel通道, 使得应用程序不需要再考虑各种不同的消息中间件实现。

==通过定义绑定器Binden作为中间层，实现了应用程序与消息中间件细节之间的隔离。==





**Stream中的消息通信方式遵循了发布-订阅模式**：Topic主题进行广播





## Spring Cloud Stream标准流程套路

![image-20210411182741461](https://i.loli.net/2021/04/11/qil9vEo53LsQmzx.png)

![image-20210411182808090](https://i.loli.net/2021/04/11/eXnf89LVQ1IrGoM.png)





## 案例

### 消息生产者





### 消息消费者



## 分组消费与持久化

运行后的两个问题：

比如在如下场景中,订单系统我们做集群部署,都会从RabbitMQ中获取订单信息,
那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。
这时我们就可以**使用Stream中的消息分组**来解决

注意在Stream中处于同一个group中的多个消费者是竞争关系,就能够保证消息只会被其中-个应用消费-次。
**不同组是可以全面消费的(重复消费),**
**同一组内会发生竞争关系，只有其中一个可以消费。**

### 分组

默认分组是不同的

可以自定义分组，产生竞争关系

```yml
group: groupA # 自定义分配组
```



## 持久化

如果说一个服务器未进行分组,如果服务端关闭,则不会受到上次的消息;

如果进行了分组,重启开启服务又能够接收到上次的信息,这就是消息持久化

==所以分组很重要==