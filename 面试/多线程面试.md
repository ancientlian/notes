# start 与 run 区别

1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可
以直接继续执行下面的代码。
2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。
3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行
run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。

# 后台线程 守护线程

1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，
在没有用户线程可服务时会自动离开。
2. 优先级：守护线程的优先级**比较低**，用于为系统中的其它对象和线程提供服务。
3. 设置：通过 `setDaemon(true)`来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是
在 线程对象创建 之前 用线程对象的 `setDaemon` 方法。
4. 在 Daemon 线程中产生的新线程也是 Daemon 的。
5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周
期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。
6. example: **垃圾回收线程**就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread, 程
序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃
圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资
源。
7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地
执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是**依赖于系统****，与**
**系统“同生共死”**。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或
以上的非守护线程则 JVM 不会退出。



# 乐观锁（非阻塞同步锁）

乐观锁是一种乐观思想，即**认为读多写少**，遇到并发写的可能性低，每次去拿数据的时候都认为别人不
会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写
时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复
读-比较-写的操作。

java 中的乐观锁基本都是通过 **CAS 操作**实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否
一样，一样则更新，否则失败。

非阻塞锁是不可重入的，否则会造成死锁。

# 悲观锁（互斥同步锁）

悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修
改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲
观锁就是`Synchronized`,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观
锁，如 `RetreenLock`。



# 自旋锁

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不
需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释
放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直
占用 cup 自旋做无用功，所以**需要设定一个自旋等待的最大时间**。

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最
大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。
自旋锁的优缺点
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大
幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次
上下文切换！
但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁
了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个
锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又
不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；
自旋锁时间阈值（1.6引入了适应性自旋锁）
自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行
时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的
性能。因此自旋的周期选的额外重要！





# 内存泄漏

## 怎样阻止内存泄露

1.使用List、Map等集合时，在使用完成后赋值为null
2.使用大对象时，在用完后赋值为null
3.目前已知的jdk1.6的substring()方法会导致内存泄露
4.避免一些死循环等重复创建或对集合添加元素，撑爆内存
5.简洁数据结构、少用静态集合等
6.及时的关闭打开的文件，socket句柄等
7.多关注事件监听(listeners)和回调(callbacks)，比如注册了一个listener，当它不再被使用的时候，忘
了注销该listener，可能就会产生内存泄露







# 线程池的处理流程

提交一个任务到线程池中，线程池的处理流程如下：
1、判断**线程池里的核心线程**是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创
建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。
2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如
果工作队列满了，则进入下个流程。
3、判断**线程池里的线程**是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已
经满了，则交给饱和策略来处理这个任务。



刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任
务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线
程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置
AbortPolicy:直接抛出异常。



# RejetedExecutionHandler：饱和策略

当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进
行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：
1、AbortPolicy：直接抛出异常
2、CallerRunsPolicy：只用调用所在的线程运行任务
3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
4、DiscardPolicy：不处理，丢弃掉。



# Executors可以创建3种类型的ThreadPoolExecutor



## a、SingleThreadExecutor：单线程线程池

```java
ExecutorService threadPool = Executors.newSingleThreadExecutor();
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService(
        new ThreadPoolExecutor(1, 1,
    	0L, TimeUnit.MILLISECONDS,
    	new LinkedBlockingQueue<Runnable>()));
}
```

我们从源码来看可以知道，单线程线程池的创建也是通过ThreadPoolExecutor，里面的核心线程数和线
程数都是1，并且工作队列使用的是无界队列。由于是单线程工作，每次只能处理一个任务，所以后面所
有的任务都被阻塞在工作队列中，只能一个个任务执行。

## b、FixedThreadExecutor：固定大小线程池

```java
ExecutorService threadPool = Executors.newFixedThreadPool(5);
public static ExecutorService newFixedThreadPool(int nThreads) {
	return new ThreadPoolExecutor(
        	nThreads, nThreads,
			0L, TimeUnit.MILLISECONDS,
			new LinkedBlockingQueue<Runnable>());
}
```

这个与单线程类似，只是创建了固定大小的线程数量。

## c、CachedThreadPool:无界线程池

```java
    ExecutorService threadPool = Executors.newCachedThreadPool();
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(
            	0, Integer.MAX_VALUE,
                60L, TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>());
    }
```

无界线程池意味着没有工作队列，任务**进来就执行，线程数量不够就创建，与前面两个的区别是：空**闲
的线程会被回收掉，空闲的时间是60s。这个适用于执行很多短期异步的小程序或者负载较轻的服务
器。



# 创建线程池的几种方式

`ThreadPoolExecutor`、`ScheduledThreadPoolExecutor`、`ForkJoinPool`

![image-20211222234110099](F:\WorkSpace\Lian\notes\面试\多线程面试.assets\image-20211222234110099.png)





# Java 多线程安全机制

我们都知道java的内存模型中有主内存和线程的工作内存之分，主内存上存放的是线程共享的变量（实
例字段，静态字段和构成数组的元素），线程的工作内存是线程私有的空间，存放的是线程私有的变量
（方法参数与局部变量）。线程在工作的时候如果要操作主内存上的共享变量，为了获得更好的执行性
能并不是直接去修改主内存而是会在线程私有的工作内存中创建一份变量的拷贝（缓存），在工作内存
上对变量的拷贝修改之后再把修改的值刷回到主内存的变量中去，JVM提供了8中原子操作来完成这一过
程：lock, unlock, read, load, use, assign, store, write。深入理解java虚拟机-jvm最高特性与实践这本
书中有一个图很好的表示了线程，主内存和工作内存之间的关系：

![image-20211223224417818](F:\WorkSpace\Lian\notes\面试\多线程面试.assets\image-20211223224417818.png)

如果只有一个线程当然不会有什么问题，但是如果有多个线程同时在操作主内存中的变量，因为8种操作
的非连续性和线程抢占cpu执行的机制就会带来冲突的问题，也就是多线程的安全问题。线程安全的定
义就是：如果线程执行过程中不会产生共享资源的冲突就是线程安全的。

## 1.互斥同步锁（悲观锁）

1）Synchorized
2）ReentrantLock

## 2.非阻塞同步锁

1) 原子类（CAS）

## 3.无同步方案

1）可重入代码
在执行的任何时刻都可以中断-重入执行而不会产生冲突。特点就是不会依赖堆上的共享资源

2）ThreadLocal/Volaitile
线程本地的变量，每个线程获取一份共享变量的拷贝，单独进行处理。

3）线程本地存储
如果一个共享资源一定要被多线程共享，可以尽量让一个线程完成所有的处理操作，比如生产者消费者
模式中，一般会让一个消费者完成对队列上资源的消费。典型的应用是基于请求-应答模式的web服务器
的设计





# 如何合理配置线程池的大小

线程池究竟设置多大要看你的线程池执行的什么任务了，CPU密集型、IO密集型、混合型，任 务类型不
同，设置的方式也不一样。
任务一般分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线 程池。

## 1）CPU密集型

尽量使用较小的线程池，一般Cpu核心数+1

## 2）IO密集型

方法一：可以使用较大的线程池，一般CPU核心数 * 2

方法二：（线程等待时间与线程CPU时间之比 + 1）* CPU数目

方法二：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。
下面举个例子：
比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核
心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)\*8=32。这个公式进一步转化为：
最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）\* CPU数目

## 3）混合型 

可以将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，按情况而定



# 任务拒绝类型

## ThreadPoolExecutor.AbortPolicy:

当线程池中的数量等于最大线程数时抛 java.util.concurrent.RejectedExecutionException 异常，
涉及到该异常的任务也不会被执行，线程池默认的拒绝策略就是该策略。

## ThreadPoolExecutor.DiscardPolicy():

当线程池中的数量等于最大线程数时,默默丢弃不能执行的新加任务，不报任何异常。

## ThreadPoolExecutor.CallerRunsPolicy():

当线程池中的数量等于最大线程数时，重试添加当前的任务；它会自动重复调用execute()方法。

## ThreadPoolExecutor.DiscardOldestPolicy():

当线程池中的数量等于最大线程数时,抛弃线程池中工作队列头部的任务(即等待时间最久的任务)，
并执行新传入的任务





# volatile、ThreadLocal的使用场景和原理



## volatile原理

volatile变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓 存行的数据
写会到系统内存。
Lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其 后面的指
令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内 存屏障这句指令
时，在它前面的操作已经全部完成。

## volatile的适用场景

### 1）状态标志,如：初始化或请求停机

也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事
件，例如完成初始化或请求停机。

```java
    volatile boolean shutdownRequested;
	...
    public void shutdown() {
        shutdownRequested = true;
    }

    public void doWork() {
        while (!shutdownRequested) {
            // do stuff
        }
    }
```

线程1执行doWork()的过程中，可能有另外的线程2调用了shutdown，所以boolean变量必须是volatile。

而如果使用 synchronized 块编写循环要比使用 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。

这种类型的状态标记的一个公共特性是：通常只有一种状态转换； `shutdownRequested` 标志从 `false`转换为` true` ，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从` false `到` true `，再转换到 `false `）。此外，还需要某些原子状态转换机制，例如原子变量。



### 2）一次性安全发布（one-time safe publication），如：单列模式

在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同
时存在。
这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的
情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构
造的对象。

```java
//注意volatile！！！！！！！！！！！！！！！！！
private volatile static Singleton instance;

public static Singleton getInstance() {
    //第一次null检查
    if (instance == null) {
        synchronized (Singleton.class) { //1
            //第二次null检查
            if (instance == null) { //2
                instance = new Singleton();//3
            }
        }
    }
    return instance;
}
```

==如果不用volatile，则因为内存模型允许所谓的“无序写入”，可能导致失败。——某个线程可能会获得一个未完全初始化的实例。==

考察上述代码中的 //3 行。此行代码创建了一个 Singleton 对象并初始化变量 instance 来引用此对象。

这行代码的问题是：**在Singleton 构造函数体执行之前，变量instance 可能成为非 null 的！**什么？这一说法可能让您始料未及，但事实确实如此。
在解释这个现象如何发生前，请先暂时接受这一事实，我们先来考察一下双重检查锁定是如何被破坏的。假设上述代码执行以下事件序列：

1. 线程 1 进入 `getInstance() `方法。
2. 由于 instance 为 null，线程 1 在 //1 处进入`synchronized `块。
3. 线程 1 前进到 //3 处，但在构造函数执行之前，使实例成为非null。
4. 线程 1 被线程 2 预占。
5. 线程 2 检查实例是否为 null。因为实例不为 null，线程 2 将instance 引用返回，返回一个**构造完整但部分初始化了**的Singleton 对象。
6. 线程 2 被线程 1 预占。
7. 线程 1 通过运行 Singleton 对象的构造函数并将引用返回给它，来完成对该对象的初始化。

### 3）独立观察（independent observation），如：定期更新某个值

安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。

【例如】假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的
volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。

使用该模式的另一种应用程序就是收集程序的统计信息。

【例】如下代码展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。

```java
public class UserManager {
    public volatile String lastUser; //发布的信息

    public boolean authenticate(String user, String password) {
        boolean valid = passwordIsValid(user, password);
        if (valid) {
            User u = new User();
            activeUsers.add(u);
            lastUser = user;
        }
        return valid;
    }
}
```



### 4）“volatile bean” 模式

volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession ）提供了容器，
但是放入这些容器中的对象必须是线程安全的。

在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必
须非常普通——即不包含约束！

```java
@ThreadSafe
public class Person {
    private volatile String firstName;
    private volatile String lastName;
    private volatile int age;

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public int getAge() {
        return age;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```



### 5）开销较低的“读－写锁”策略，如：计数器

如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。

如下显示的线程安全的计数器，使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile 读操作，这通常要优于一个无竞争的锁获取的开销。

```java
@ThreadSafe
public class CheesyCounter {
    // Employs the cheap read-write lock trick
    // All mutative operations MUST be done with the 'this' lock held
    @GuardedBy("this")
    private volatile int value;

    //读操作，没有synchronized，提高性能
    public int getValue() {
        return value;
    }

    //写操作，必须synchronized。因为x++不是原子操作
    public synchronized int increment() {
        return value++;
    }
```

使用锁进行所有变化的操作，使用 volatile 进行只读操作。

其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作



## ThreadLocal原理

ThreadLocal是用来维护本线程的变量的，并不能解决共享变量的并发问题。ThreadLocal是 各线程将
值存入该线程的map中，以ThreadLocal自身作为key，需要用时获得的是该线程之前 存入的值。如果
存入的是共享变量，那取出的也是共享变量，并发问题还是存在的。

## ThreadLocal的适用场景

场景：数据库连接、Session管理